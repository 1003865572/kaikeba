程序员基本功
1.算法
    突破2万（3 - 4万）
2.设计模式
    突破5万
3.架构
    突破10万
------------------------------------------------------------------------------
设置 header 的两种方法
writeHeader
setHeader

------------------------------------------------------------------------------
10 个问题
1. post 数据为什么要 分段上传
    1. 不会阻塞网络（路由器单此服务一个终端，数据流过大，其他用户就得等着）
    2. 容错能力强，如果当前数据包出错了，重发的代价小
2. nodejs 如何取值 get post 请求的数据
    get 数据在 req.url 中
        let { pathname, query } = urlLib.parse(req.url, true)
    post 数据在 req.on('data', data => {}) 的事件中
        let arr = []
        req.on('data', data => arr.push(data))
        req.on('end', () => {
            console.log(arr);
        })
3. 解释 关系型数据库，文件行数据库，非关系型数据库
4. node 垃圾回收

5. nodejs 缓存（http 缓存）
    第一次：get xxx 
        服务器发送
            status: 200
            cache-control: 缓存到底要怎么处理（比如不缓存）
                            public      读取浏览器本地的缓存
                            private     第一次浏览器请求服务器的内容，此后浏览器值读取自己本地的缓存
                            no-cache    不缓存
                            no-store    不缓存
            expires         数据的有效期
            data            接口返回的资源的有效期是多少
    第二次
        浏览器发送
            data            文件修改时间
        服务器发送
            查接收修改时间，看看浏览器缓存的是否和服务器的版本一样
            一样
                304
            不一样
                重新发送 请求结果， 和第一次一样
6. 垃圾回收
    实现的基本逻辑是 引用计数，一个对象 let a = new A() 了之后 要一直等到  a = null; 时才会被释放
    如果
        let a = new A();
        let a2 = a;
    此时 a 和 a2 都被指向一个内存空间。但如果 a 和 a2 都 ==== null 的时候， 这块空间就会被自动释放了。

7. js 内存泄露
8. 服务器缓冲池
    说白了就是把常用的资源（数据，html，配置，活动页面, 等）直接放在服务器内存中，有人访问到这部分资源时直接去内存取（这就是缓冲命中）
    缓冲命中率 
        （缓存命中数 / 所有的请求数）* 100
